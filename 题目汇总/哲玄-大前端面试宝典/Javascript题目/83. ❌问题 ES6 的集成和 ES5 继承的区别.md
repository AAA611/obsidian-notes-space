## TODO

- [ ] 复习原型链、继承知识
## ES6 继承

```js
class Animal {
  constructor(name) {
    this.name = name
  }

  walk() {
    console.log(this.name + ' walk');

  }
}

class Dog extends Animal {
  constructor(name) {
    super(name)
    this.animalType = 'Dog'
  }

}

const dog1 = new Dog('hah')

dog1.walk() // hah walk

```

## ES5 继承

### 原型链继承

```js
function Animal(name) {
  this.name = name
}

Animal.prototype.walk = function () {
  console.log(this.name + ' walk');
}


function Dog(name) {
  this.name = name
}

Dog.prototype = new Animal()

const dog1 = new Dog('hah')

dog1.walk()
```

<mark style="background: #FF5582A6;">原型链继承的问题</mark>：

- 引用类型会被所有的实例共享
- 创建实例的时候不能向构造函数传递参数

### 借用构造函数

主要思想：在子类构造函数中调用父类的构造函数，创建实例时可以向父类构造函数传递参数了

<mark style="background: #FF5582A6;">问题</mark>：每个实例对象都拥有从父类继承来的函数、其他引用类型的对象，多个实例无法服用函数。

### 组合继承

主要思想：组合原型链继承与构造函数继承

调用父类构造函数初始化实例自己的属性

利用原型链继承共享一些需要共享的如函数等属性

<mark style="background: #FF5582A6;">问题</mark>：调用了两次父类构造函数

### 原型式继承

### 寄生式继承

寄生式继承在原型继承的基础上进行扩展