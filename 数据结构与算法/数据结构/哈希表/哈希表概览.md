> [Hello 算法--哈希表](https://www.hello-algo.com/chapter_hashing/)

## 哈希表介绍

哈希表（hash table），又称散列表，它**通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询**。

复杂度分析对比：

- **添加元素**：仅需将元素添加至数组（链表）的尾部即可，使用 𝑂(1) 时间。
- **查询元素**：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 𝑂(𝑛) 时间。
- **删除元素**：需要先查询到元素，再从数组（链表）中删除，使用 𝑂(𝑛) 时间。

![[Pasted image 20240714094921.png]]

## 术语介绍

**桶（Buckets）**: 
用于存储数据（键值对）的数据结构，一般是数组。

**哈希函数（Hash Function）**: 
在哈希表的实现中，key 与桶索引 index 的关系映射是由哈希函数来实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 `key` ，输出空间是所有桶（数组索引）。换句话说，输入一个 `key` ，**我们可以通过哈希函数得到该 `key` 对应的键值对在数组中的存储位置**。

**哈希冲突**：
哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。所以就一定会有多个相同的 key 映射到同一个索引 index 上面去。这就是哈希冲突

**负载因子**：
负载因子是哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，**也常作为哈希表扩容的触发条件**

## 解决哈希冲突

### 扩容

由于哈希冲突产生的原因是：将一个较大的输入空间 `M` 映射到一个较小的输出空间 `N`，那么只有 `N` 变得更大，就可以一定程度上缓解哈希冲突

### 链式地址

在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。

### 开放寻址

开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。
