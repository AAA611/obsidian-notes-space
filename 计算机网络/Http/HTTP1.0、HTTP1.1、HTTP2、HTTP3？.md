## Http 1. x 

### 有什么问题？

**队头阻塞**，Http 1.1 虽然可以通过 keep-alive 头部来实现对同一个连接的复用，但是同一个连接上的多个请求仍然需要按照顺序进行请求与响应，后面的请求需要等待前面的请求完成。如果前面的请求阻塞了，后面的都需要等待。

**臃肿的消息头部**，请求的首部无法被压缩。尽管它比响应资源小得多，但它可能占据请求的绝大部分，未压缩的首部会占用更多的带宽。

**受限的优先级设置**

## Http 2

### Http 2 带来了哪些改变？

**基于二进制的协议**，<mark style="background: #BBFABBA6;">Http 2 是基于帧的二进制协议</mark>，二进制数据有利于机器的解析，但缺点是不利用开发人员查看、调试。

> Http 1. x 是基于文本的协议，解析慢、但便于查看、调试。

**首部压缩**，Http 2 的请求首部会被深度压缩。这将显著减少传输中的冗余字节。Http 2 使用基于<mark style="background: #BBFABBA6;">表查找</mark>的 `HPACK` 进行首部压缩，客户端与服务端各自维护着索引到首部的表，发送首部时只发送索引，服务端接收到首部时进行表查找。

> Http 1. x 没有首部压缩机制

**多路复用**, Http 2 实现了真正的多路复用, 基于帧的消息传输可以让多个请求的帧消息交织传输, Http 2 可以正确识别某个帧是属于哪个请求, <mark style="background: #BBFABBA6;">属于同一个请求的帧消息视为一个流 (Stream)</mark>

> Http 1. x 没有实现真正意义上的复用。Http 1. 1 只是可以多次复用同一个 TCP 连接，但只能按找顺序请求、响应。存在队头阻塞问题，网络资源利用率不高。

**加密传输**， Http 2 必须开启 Https ,加密传输信息更加安全

> Http 1. x 不强制使用 Https，Http 2 强制使用 Https。

**服务端推送**，服务端推送指的是客户端发送一个请求，服务端就能预测客户端接下来的请求，从而<mark style="background: #BBFABBA6;">把一些资源提前推送给客户端</mark>。但这要求服务端的实现足够智能。

> Http 1. x 没有服务端推送功能

### Http 2 仍然存在一些问题

TCP 层面的队头阻塞，由于 TCP 提供的是可靠传输，且 TCP 保证数据的有序。如果 Http 2 仅使用一个 TCP 连接来承担页面上面所有资源的请求时，那么如果某个数据包出现了丢失，那么 TCP 则需要进行丢包检测、重传机制。这回阻塞后面数据包的传输。

[[HTTP 2.0 存在哪些问题？]]
## Http 3-未来的展望

### 参考

[Http 3](https://http3-explained.haxx.se/zh/why-quic/why-tcphol)