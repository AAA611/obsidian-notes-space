
## 从进程调度谈起

现代操作系统（如 Windows、Linux 等）都是分时系统。分时系统允许同时允许多个任务，但实际上，由于一台计算机通常只有一个 CPU，所以不可能真正地同时运行多个任务。这些进程实际上是轮番运行，每个进程运行一个时间片。由于时间片通常很短，用户不会感觉到，所以这些进程看起来就像是同时运行。

每个进程的时间片由操作系统完成初始化，所有进程轮番地执行相应的时间。具体下一个时间片轮到哪个进程来执行，是由操作系统决定的，我们把操作系统选择下一个任务的过程称为“调度”。

当一个进程处于它的时间片时，正常情况下会独享 CPU，不断运行直到当前时间片被用完。但是让我们想象这样一个场景：当一个进程发起 `open()` 系统调用去读取某个文件的内容时，因为 CPU 的速度远远大于从硬件读取内容的速度，所以大部分时间 CPU 都在等待硬盘读取完成，这无疑造成了 CPU 浪费。

因此，当某个进程发起 `open()`、`read()` 等系统调用时，OS 会**阻塞**这个进程，让出 CPU 去执行别的任务。而读取任务实际上由 DMA 完成，当读取完毕后，DMA 会发出一个 I/O 中断通知 OS，OS 会从暂停位置继续这个进程。

有时候我们可能会看到这样的说法：“当某个进程发起阻塞调用时，它会被**挂起**”。阻塞是指进程在等待事件，暂时让出 CPU；挂起是指进程被换出到外存，等待激活。在讨论阻塞/非阻塞时，我们一般不区分“阻塞”和“挂起”，因为对进程而言，阻塞和挂起都是失去 CPU、无法运行的状态。当然，它们两个还是有一些细微的区别，可以查看[这篇文章]进一步了解。
## 阻塞、非阻塞

阻塞与非阻塞主要描述的是进程的状态。即一个进程在发起系统调用后，是否会被阻塞。

如果是一个阻塞调用，那么进程会被挂起。等到调用完成之后才会被唤醒。

如果是一个非阻塞调用，那么调用会立即返回，进程不会被挂起，还可以继续做其他事情。

## 同步、异步

同步调用：调用之后能礼记返回结果，在返回结果前不能干其他事情

异步调用：调用之后立即返回，在将来的某个时间点会哦以某种形式（比如说回调）来通知调用方


## 参考

[Site Unreachable](https://blog.csdn.net/qq_40837310/article/details/106108254)