
## 前端依赖治理的挑战

### 1 、基于 semver 的版本管理可能并不稳定。

node-semver 版本管理可以采用范围或者通用符号 (\*、x、X) 来声明依赖的版本号。但有些项目可能并没有严格遵守 semver 版本规范。

解决：
1. **核心依赖锁死版本号**

### 2 、幽灵依赖

幽灵依赖指的是那些没有在项目的 `package. json` 中显式声明的依赖，却可以在项目中导入并使用。造成这种现象的原因有以下两个方面：

1. `node` 的包寻址方式（主要逻辑就是沿着项目的根目录一直向上找 `node_modules` 文件夹，然后在 `node_modules` 文件夹中寻找是否有指定的依赖）
2. 包管理器如 `npm`、`yarn` 的某些版本为了解决过深的依赖结构和相同版本依赖的重复下载，会将依赖结构打平存放在 `node_modules` 文件夹内，这样就导致了项目中可以使用到项目依赖的依赖。

如何解决：
1. **使用 `pnpm`**，`pnpm` 的基于软链接的 `node_modules` 结构可以解决大部分的幽灵依赖问题。
2. **使用 ESlint 工具协助**，`ESLint` 提供了不少规则用于检测幽灵依赖，例如 `import/no-extraneous-dependencies`，只需要在项目中启用即可。
3.  **使用 [depcheck](https://link.segmentfault.com/?enc=WgaLw2OJNghvZ0CWUJLTWQ%3D%3D.Z7nrOFUfycbpLShTdmceIsCBV8IQ7FdUSqZV%2Bl%2BgJ0RQ9rOlRZwYf69JknRlm9gx)**：这是一个用于检测未使用的或缺失的 npm 包依赖，可以协助发现现存代码可能存在的幽灵依赖，类似的还有：`npm-check` 等。

### 3 、依赖冲突

依赖冲突指的是项目中的依赖存在不同的版本，版本之间的冲突。

例如项目 `P` 依赖了 `A`、 `B` , 而 `A` 赖了 `C@1.0.0` ，`B` 依赖 `C@1.1.1` 。这个时候就存在依赖 `C` 的版本冲突。包管理器在打平依赖树的时候，如果发现了最上层的依赖列表已经存在了依赖 `C`，那么另一个版本的依赖 `B` 就会被安装在依赖它的依赖的 `node_modules` 下面。这个顺序是不能保证的，比如 `C@1.0.0` 先被放在顶层中，那么 `C@1.1.1` 就会被安装在 `B` 下面的 `node_modules` 下面。反之如果 `C@1.1.1` 先被安装在顶层，那么 `C@.1.0.0` 就会被安装在 `A` 的 `node_modules` 下面。

这个顺序不能保证，主要取决于谁先被安装到打平后的顶级 `node_modules` 中。

解决：
1. **使用 pnpm**，`pnpm` 基于软链接到的 `node_modules` 结构不会出现这个问题。

### 4 、冗余的依赖

在一个复杂项目存在冗余的依赖是难以接受了，这会增加项目依赖的复杂度，而且可能会对其他成员造成困惑。

解决：
1. **定期检查**，可以人工核查，也可以使用工具如 `npmcheck`、`depcheck` 来扫描依赖的情况。
2. **谨慎添加新的依赖**，添加新的依赖要进行小组审查。
3. **`pnpm why <package>`**

## 依赖检查工具

1、npm-check
2、dep-check