---
tags:
  - 算法
  - 动态规划
  - 最长递增子序列
---

![[Pasted image 20240625160843.png]]
## 分析
1. 拆分子问题：
	- 把原问题拆分为以 `nums[i]` 结尾的最长递增子序列，这样我们就得到了 `nums.length` 个子问题，子问题之间相互独立。通过比较各个子问题的最优解可以得到最终的最优解。因此需要一个长度为 `nums.length` 的 `dp` 数组来存储子问题的最优解。
1. 确认 base：
	- 确认 base 是动态规划中的重要一环，由于动态规划是自底向上求解，即根据最简单的子问题往上推直到得到我们想要的大问题（最终问题）的答案。在拆分子问题时已经创建了 `dp` 数组，`dp` 数组的初始值便是 `base`。以 `nums[i]` 结尾的最长递增子序列至少要包含自己，因此 `dp[i]` 的 `base` 是 `1`。
1. 状态转移方程：
	- 最后我们需要找出子问题之间的关联，即如何通过一个子问题的最有解题推出下一个子问题的最优解，这也是动态规划思想避免重复计算的重要步骤。
	- 假设我们需要求 `dp[2]`，现已知 `dp[1],`他们有着什么样的关系呢，我们怎么才能利用 `dp[1]` 的解来推出 `dp[2]` 的解呢？既然是递增子序列，那么只需要找到 `nums[2]` 前面那些结尾比 `nums[2]` 小的子序列，然后把 `nums[2]` 拼到后面，就可以形成一个新的子序列，而且这个新的子序列长度加 `1`
		```js
		for(let j=0;j<i;j++){
			if(nums[i]>nums[j]){
				dp[i]=Math.max(dp[i],dp[j]+1)
			}
		}
```

## 解题思路与技巧

1. **按以 nums[i] 结尾的最长子序列来拆分子问题**