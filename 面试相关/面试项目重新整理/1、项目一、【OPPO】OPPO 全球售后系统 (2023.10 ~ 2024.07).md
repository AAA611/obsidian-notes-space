`Vue2全家桶` `ElementUI` `Webpack` `WebSocket`
- **项目描述**
	 OPPO 的全球售后管理系统，用于提供 OPPO 网点、服务商、总部之间的售后服务。主要功能有客服系统、工单管理、整机备件管理、物料管理等多个核心业务模块
- **人员规模**
	 研发：20+ ，前端：10+
- **负责内容**
	1. 担任部分业务模块前端负责，负责任务分配、codereview、代码审核与合并
	2. 推动提高代码的可维护性，参与制定开发规范，推动项目中“坏”代码的评审与重构
	3. 项目工单、备件整机等核心业务模块的开发
	4. 实现提高 API 资源配置效率的 Webpack 插件
	5. 上线多语言自动化脚本优化、开发
- **难点与亮点**
	1. 客服通话功能，基于 WebSocket + SharedWorker 实现浏览器多页签共享 Websocket 连接、状态同步
	2. 实现高精度的计时器满足客服通话计时需求
	3. 实现 Webpack 插件，自动分析页面依赖的 API 资源，提高 API 权限资源配置效率，降低人力成本与出错率
	4. 发现项目上线时配置多语言的痛点，实现自动化脚本提升效率，降低时间成本与出错率。涉及大量数据的对比与查找，使用哈希表优化脚本时间复杂度

TODO：

需要补足的知识：

1、如何进行 codereview 的？
2、关于 Webpack Plugin 的细节内容
3、WebSocket 与 SharedWoker
4、高精度的计时器（要熟练记住整个的实现流程）
5、是怎么优化上线脚本的

### WebSocket + SharedWorker 实现多 Tab 共享 Websocket 连接，多 Tab 页状态同步是怎么做的？为什么选择这么做？

**背景**：项目中有一个通话功能，这个功能的实现需要浏览器页面与本地的一个通话软件进行 websocket 通信，如果用户打开多个 tab，每个 tab 都建立一个通信显然有些浪费资源。所以基于这个问题我们需要想一种能够节省这种资源开销的一个方案。

**方案构想**：我们想的是能不能在多个 tab 页共享同一个 websocket 连接，多个 tab 使用某种机制进行状态同步。首先共享就需要有一个独立于多个 tab 之外的一块区域使得多个 tab 都能够与之进行某种通信，这一般有本地存储（localStorage、sessionStorage）、ServiceWorker、SharedWorker。

- localStorage 方案知识存储一些简单的 key、value，并不能满足这个共享 websocket 连接这样一个复杂的需求，所以舍弃
- SharedWorker SharedWoker 是一种特殊的 worker，它可以被多个浏览器 tab 所共享，在 SharedWoker 脚本里进行与本地通话软件的 websocket 连接，SharedWorker 中收到消息之后再转发给各个浏览器 tab

鉴于上面考虑，最终选择了使用 SharedWoker 来进行 websocket 连接，多个浏览器 tab 通过 SharedWoker 共享同一个 websocket 连接

**成果**：功能在线上平稳运行，能满足目前的业务场景、需求

### 高精度计时器是怎么做的？

**背景**：项目中的客服通话需要计时功能，使用 setTimeout 实现的话，由于 setTimeout 的执行准确度受到事件循环的影响，如果有较长任务的话会导致 setTimeout 的执行时机偏差较大，而定时器一般需要持续运行 5-20 分钟不等，累计下来的偏差可能是一个较大值。所以我想到实现一个相对来说拥有较高精度的计时器来满足这个效果

**方案设想**：想要提高计时器的精度，首先需要一个准确的时间标准，我们在计时器开始时使用 `Date.now()` 来记录计时器的开始时间 `start` ，在每次 `tick` 时再使用 `Date.now() - start` 来得到计时器的实际运行时间 `elapsedTime`，然后再使用 `elapsedTime - seconds*1000` 来得到当前的时间误差（seconds 表示当前计时记了多少次时，一般是一秒一次）。最后我们根据这个计算得到的误差时间来在每个 tick 中动态计算 setTimeout 的 wait，以此来达到动态调整偏差的目的。

**成果**：在让这个计时器运行了一个相对较长的时间之后我们发现实际的误差值基本稳定在一个可接受的范围之内，误差不会一直累计从而导致最终的误差较大。

### Webpack Plugin 实现自动分析页面依赖的 API 资源是怎么做的？

**背景**：项目中有做权限设计，每个API 都是 API 权限资源。项目权限的大体结构是：菜单资源=>页面资源=>API 资源、按钮资源。API 资源隶属于某个页面资源，当同一个 API 资源再多个页面中被使用时，这个 API 资源需要在权限树中配置多次，每个依赖这个 API 资源的页面下面都需要配置。由于我们系统的环境比较多（dev 开发环境、test 测试环境、uat 用户验收环境、海外环境等等），每个环境的数据库都不一样，所以如果权限资源更改时可能需要配置资源信息到多个环境，手动操作的话比较耗时而且工作量大容易出错可能有遗漏也耽误工时。鉴于上面一些问题呢，就想能不能把一些工作自动化起来，这样提高效率同时也降低出错的概率。

**方案设想**：由于需要分析页面=>API 资源的依赖关系，所以基于一些打包工具如 webpack 具有天然优势，因为 webpack 会分析整个项目模块的依赖关系，如果能在此基础上再针与我们自己的场景需要做进一步的分析是否就可以得到页面=>API 的依赖关系。webpack 插件 API 提供了很多不同阶段的钩子，不同的钩子也可以拿到不同的信息，所以我们使用 webpack 插件来做这个事情

**如何实现的**：使用的时 finishedModules 这个钩子，这个钩子在 webpack 编译完所以模块时被调用，回调接收的参数是 modules（一个包含了所以 module 信息的数组）。接下来我们需要根据这个数据来做进一步的分析，主要分为下面几个步骤：

- 第一步：根据 modules 做一些筛选，主要根据 module. resource 信息（<mark style="background: #FF5582A6;">TODO：resource 信息是什么</mark>）来筛选出 apiModules (路径中带有 /apis/ 的模块)、routerModules（路径中带有 /router/ 的模块），再根据 routerModules 得到 pageModules（因为 routerModules 中包含对 page 组件模块的动态引入）
- 第二步：使用 @babel/traverse 来分析 routerModules 各个模块的 AST 信息，得到 routerInfoList 信息
- 第三步：分析 pageModules 各个模块，提取 api 特征引入即地址中带有 /apis/ 的引入，则视为这个引入的 API 是属于这个 page 的依赖的 API。这个过程是递归的，如果一个 vue 文件依赖了另一个 vue 文件，那么要递归去查找（<mark style="background: #FF5582A6;">TODO：再看一下插件代码</mark>）对这个 API 引入的函数名称进行分析
- 第四步：分析 pageModules 的各个 module，循环递归分析 module 的依赖 deps，然后筛选掉一些不是 [[HarmonyImportSpecifierDependency 是什么？]]类型的依赖项，这里也要筛选掉一些类型是 HarmonyImportSpecifierDependency 类型但是 name 是 render、normalizer、staticRenderFns 的依赖项，因为这些是 vue-loader 编译. vue 文件后的导入，不需要做分析。筛选出来的依赖项做递归分析，分析依赖模块的 resource 是否是某个 apiModule 的 resource，如果是则说明这个依赖是一个 API 依赖，

**成果**：通过 webpack 插件自动化分析 API 依赖关系，大大减少了配置多个环境的权限资源的人工成本，降低了出错概率。

### 上线脚本式如何进行优化的？

**背景/痛点**：每次上线都需要对比本地与远端的中文词条的差异，得到本次新增的词条列表 list 1
然后根据 list 1 去整个翻译表格中去查找翻译，得到能找到翻译的词条列表 list 2 与没有找的翻译的词条列表 list 3

新增的词条 list 1、有翻译的 list 2 可以直接导入到系统
list 3 则需要暂时使用公司的翻译软件翻译之后再导入到系统。并且这些词条还需要记录到下一个迭代中的带翻译目录中。

由于项目的多语言词条较多，每种语言有 1-2 万个左右，所以认为操作不仅麻烦而且一步错，步步错。

**优化方案**：将上述的过程尽可能使用脚本自动化，使用 xlsx 进行 excel 操作。读取词条并对比，输出可用的文件。

由于翻译表格数据很多，每次通过遍历查找性能较低，所以使用 HashMap 来遍历一次建立索引来进行后续的查找优化。

**成果**：降低了人工操作的时间，也提高了可靠性。

