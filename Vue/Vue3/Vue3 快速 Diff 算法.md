## 介绍

快速 Diff 相比于传统 Diff，多了个**预处理**的步骤。这借鉴了纯文本的 Diff 算法的思路。

预处理指的是在 Diff 之前，先处理前后两头相同的元素。

例如对比 [1,2,3,4,5,6] 与 [1,2,8,9,5,6] 时，在对两头相同的元素进行了预处理之后，实际上只需要对比 [3,4] 与 [8,9]

## Vue3 中快速 Diff

### 前后相同节点预处理

核心思想是开启两个循环分别先处理前后相同的节点部分。

代码如下：

![[image-20240807225824898.png]]

### 仅新增节点

仅新增节点指的是在第一步预处理完之后，出现下面情况：

- 旧的节点已经遍历完毕
- 新的节点还没有遍历完毕

![[image-20240807225939747.png]]

### 仅删除节点

仅新增节点指的是在第一步预处理完之后，出现下面情况：

- 新的节点已经遍历完毕
- 旧的节点还没有遍历完毕

这个时候就需要进行旧节点的删除

![[image-20240807230408661.png]]

### 处理非处理情况

很多情况下，情况并没有那么理想，在进行了预处理之后，新旧节点都还有剩余。


### ⭐最长递增子序列在 Diff 中到底有什么用？

首先，我们必须清楚一个很重要的点：我们在 Diff 的过程中是通过对比新旧节点来操作**旧的节点**。注意，这里操作旧的节点一定要清楚。

怎么确定要不要移动移动节点？

答案是通过遍历旧节点，然后是查找对应的旧节点在新节点中的位置，我们是从前到后遍历旧节点，索引自然是递增的，

那么如果这些节点在新的节点中的索引也是递增的，那么就没有要移动节点。

当然如果有需要移动的节点的话，那么旧节点在新节点中的索引顺序旧就会有不是递增的情况，这就说明我们需要移动节点

那么我们根据这个索引数组来得到一个最长递增子序列，存在于这个子序列里面的元素都是不需要移动的。