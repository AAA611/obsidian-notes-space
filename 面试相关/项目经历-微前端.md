项目描述：
人员规模：
技术栈 Vue 2.6 全家桶、qiankun 等
负责内容：
- qiankun 框架调研与测试可行性
- 项目部分内容搭建
- 核心功能模块的代码开发、review
- 主、子应用部分公共组件的开发、维护
难点与亮点：
- qiankun 方案的探索与接入
- webpack 优化以提高开发时构建速度，提高上线时的首屏性能
- 微前端中多页签的实现，后续使用 LRU 算法优化使用内存过大问题



## 可能会问到的问题

1、公共组件库，你主要开发了哪些组件？有哪些比较复杂的组件吗？
2、qiankun 相关
3、webpack 是怎么优化的？
4、多页签的实现细节

### 你主要封装了哪些公共组件？有比较复杂的组件吗？

A：有 UseAsync 异步请求组件，
- 是一个抽象组件，不渲染东西，只执行一些逻辑。主要接收 depends 依赖参数和 setup 参数。
- depends 参数表示组件的依赖项，组件内部会深度 watch ，在 depends 变化时重新执行 setup 里面提供的方法。
- setup 参数是一个对象，里面主要有请求的函数与设置默认值的函数
- 另外组件还提供了 serial 参数来控制多个请求是否需要串行执行，否则将并行执行。内部使用队列实现

A：有 UseDict 组件，主要作用是用于获取字典项，通常用在一个页面组件的最外层，也是一个抽象组件。

这个组件的作用主要是解决项目中的数据字典使用的地方较多，缺少统一的组件来管理这个公共逻辑。

通过抽象一个公共组件可以实现对数据字典的批量请求。同时在开发时一个组件依赖的数据字典 code 会写在组件的最外层，便于阅读。

A：axios 的二次封装，封装为项目中公共使用的 request 方法。

主要是对 Token 的处理、接口签名、http 错误码、业务错误码的拦截处理、统一弹窗。

A：文件异步上传加轮询

#### UseAsync 这个组件解决了哪些问题？（封装这个组件的意义是什么？）

这个组件主要解决了当一个接口请求需要依赖多个数据源时。

如果直接在页面上写这些逻辑，可能需要在初始化时在 created 钩子中执行一次，然后多个数据源都需要分别 watch，然后再在 watch 的回调中写调用请求的逻辑。这样会导致逻辑分散（同一个逻辑分散到 created 钩子与多个 watch 中），不利于提高代码的可读性与可维护性，且会导致代码冗余。并且很难控制接口的串行、并行请求。

通过抽取上述情况中的逻辑为公共组件，很多地复用了代码逻辑，提高代码可维护性。通过队列可实现对请求顺序的控制。

### 简单说一下 qiankun 是什么？它有哪些特点？优点？

qiankun 是一个基于 single-spa 二次封装的微前端框架。它有如下几个特点：

- 开箱即用，接入相对简单。
- 基于 single-spa。基于路由的微前端模式
- 基于 HTML-Entry 加载子应用
- 框架无关

有以下优点：

 - 接入简单，开箱即用
 - 预加载，提高性能
 - JS 沙箱隔离，样式隔离
 - 可同时加载多个子应用

### 为什么选择了 qiankun

A：在选择一个微前端框架时，我们可能会考虑下面几点：
- **适用性**，框架是否能够满足业务开发需要，这一点是比较重要的，毕竟一切以业务为基础。<mark style="background: #BBFABBA6;">qiankun 可以满足</mark>
- **稳定性**，框架是否是比较可信的，这一般要求框架是大厂出品或者在 github 上面有较高的 star。 <mark style="background: #BBFABBA6;">qiankun 孵化于蚂蚁集团，并且在内部有多个应用的成功案例</mark>
- **可落地**：框架的可用性最好已经经过市场的验证、大厂背书。<mark style="background: #BBFABBA6;">qiankun 在大厂内部有多个成功案例</mark>
- **接入时的复杂性、侵入性**：接入微前端框架时是否需要做大量的改造？对现有项目会造成什么样的影响？是否可预估？<mark style="background: #BBFABBA6;">由于时新项目重构为微前端，所以不存在对老项目的侵入性问题，而且 qiankun 方案基本上也做到了开箱即用，改动较小。</mark>
A：而且 qiankun 被较多团队或公司使用，很多坑都已经被踩过，而且基本上有一些可接受的处理方案。官方文档也有一些 FQA 可以快速解决在接入时遇到的问题。

### 你是怎么让多个子应用同时存活的？

使用 qiankun 提供的 registerMicroApp API，使用这个 API 时要注意需要自己管理子应用的加载与卸载。

项目中使用了多页签，在某一个应用的页签全部被关闭时，调用子应用实例的 unmount 来进行卸载。
### 在使用 qiankun 时主要遇到了些什么问题

#### 路由冲突问题

#### 子应用加载 404 问题

[[Webpack 配置之【output.publicPath】]]

### Webpack 是怎么优化的？

开发时的构建优化

1、使用 bable-cache 开启持久化缓存
2、dll 第三方公共依赖缓存
3、合理使用 devtool，不需要调试的时候关闭 sourcemap 可以提高速度

生产构建优化

1、分块，使用动态导入+Webpack 魔法注释进行分块，按需加载。
2、代码压缩

### 多页签是如何实现的

多页签是在浏览器的一个 tab 页中可以开启多个路由标签，可以方便用户快速在多个应用之间进行切换、操作等。

遇到的问题：

1、keep-alive 缓存
2、页签数量应该加以管理，避免内存使用过大，使用 [LRU](https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6) 算法进行优化。




